//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g 2014-07-04 18:37:25

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class SimpleBooleanParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "LPAREN", "OR", "RPAREN", "WORD", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int LPAREN=5;
	public const int OR=6;
	public const int RPAREN=7;
	public const int WORD=8;
	public const int WS=9;

	// delegates
	// delegators

	public SimpleBooleanParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public SimpleBooleanParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);

		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();


		OnCreated();
	}
		
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return SimpleBooleanParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	private sealed partial class compileUnit_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public compileUnit_return(SimpleBooleanParser grammar) {OnCreated(grammar);}
		partial void OnCreated(SimpleBooleanParser grammar);
	}

	partial void EnterRule_compileUnit();
	partial void LeaveRule_compileUnit();

	// $ANTLR start "compileUnit"
	// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:6:1: compileUnit : EOF ;
	[GrammarRule("compileUnit")]
	private SimpleBooleanParser.compileUnit_return compileUnit()
	{
		EnterRule_compileUnit();
		EnterRule("compileUnit", 1);
		TraceIn("compileUnit", 1);
		SimpleBooleanParser.compileUnit_return retval = new SimpleBooleanParser.compileUnit_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF1 = default(IToken);

		object EOF1_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "compileUnit");
		DebugLocation(6, 1);
		try
		{
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:7:2: ( EOF )
			DebugEnterAlt(1);
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:7:4: EOF
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(7, 4);
			EOF1=(IToken)Match(input,EOF,Follow._EOF_in_compileUnit40); 
			EOF1_tree = (object)adaptor.Create(EOF1);
			adaptor.AddChild(root_0, EOF1_tree);


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compileUnit", 1);
			LeaveRule("compileUnit", 1);
			LeaveRule_compileUnit();
		}
		DebugLocation(8, 1);
		} finally { DebugExitRule(GrammarFileName, "compileUnit"); }
		return retval;

	}
	// $ANTLR end "compileUnit"

	public sealed partial class expr_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public expr_return(SimpleBooleanParser grammar) {OnCreated(grammar);}
		partial void OnCreated(SimpleBooleanParser grammar);
	}

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:19:1: expr : andexpr ;
	[GrammarRule("expr")]
	public SimpleBooleanParser.expr_return expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		SimpleBooleanParser.expr_return retval = new SimpleBooleanParser.expr_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		SimpleBooleanParser.andexpr_return andexpr2 = default(SimpleBooleanParser.andexpr_return);


		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(19, 14);
		try
		{
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:19:6: ( andexpr )
			DebugEnterAlt(1);
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:19:8: andexpr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(19, 8);
			PushFollow(Follow._andexpr_in_expr145);
			andexpr2=andexpr();
			PopFollow();

			adaptor.AddChild(root_0, andexpr2.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(19, 14);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	private sealed partial class andexpr_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public andexpr_return(SimpleBooleanParser grammar) {OnCreated(grammar);}
		partial void OnCreated(SimpleBooleanParser grammar);
	}

	partial void EnterRule_andexpr();
	partial void LeaveRule_andexpr();

	// $ANTLR start "andexpr"
	// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:20:1: andexpr : orexpr ( AND orexpr )* ;
	[GrammarRule("andexpr")]
	private SimpleBooleanParser.andexpr_return andexpr()
	{
		EnterRule_andexpr();
		EnterRule("andexpr", 3);
		TraceIn("andexpr", 3);
		SimpleBooleanParser.andexpr_return retval = new SimpleBooleanParser.andexpr_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND4 = default(IToken);
		SimpleBooleanParser.orexpr_return orexpr3 = default(SimpleBooleanParser.orexpr_return);
		SimpleBooleanParser.orexpr_return orexpr5 = default(SimpleBooleanParser.orexpr_return);

		object AND4_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "andexpr");
		DebugLocation(20, 31);
		try
		{
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:20:9: ( orexpr ( AND orexpr )* )
			DebugEnterAlt(1);
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:20:11: orexpr ( AND orexpr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(20, 11);
			PushFollow(Follow._orexpr_in_andexpr152);
			orexpr3=orexpr();
			PopFollow();

			adaptor.AddChild(root_0, orexpr3.Tree);
			DebugLocation(20, 18);
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:20:18: ( AND orexpr )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==AND))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:20:19: AND orexpr
					{
					DebugLocation(20, 22);
					AND4=(IToken)Match(input,AND,Follow._AND_in_andexpr155); 
					AND4_tree = (object)adaptor.Create(AND4);
					root_0 = (object)adaptor.BecomeRoot(AND4_tree, root_0);

					DebugLocation(20, 24);
					PushFollow(Follow._orexpr_in_andexpr158);
					orexpr5=orexpr();
					PopFollow();

					adaptor.AddChild(root_0, orexpr5.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("andexpr", 3);
			LeaveRule("andexpr", 3);
			LeaveRule_andexpr();
		}
		DebugLocation(20, 31);
		} finally { DebugExitRule(GrammarFileName, "andexpr"); }
		return retval;

	}
	// $ANTLR end "andexpr"

	private sealed partial class orexpr_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public orexpr_return(SimpleBooleanParser grammar) {OnCreated(grammar);}
		partial void OnCreated(SimpleBooleanParser grammar);
	}

	partial void EnterRule_orexpr();
	partial void LeaveRule_orexpr();

	// $ANTLR start "orexpr"
	// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:21:1: orexpr : atom ( OR atom )* ;
	[GrammarRule("orexpr")]
	private SimpleBooleanParser.orexpr_return orexpr()
	{
		EnterRule_orexpr();
		EnterRule("orexpr", 4);
		TraceIn("orexpr", 4);
		SimpleBooleanParser.orexpr_return retval = new SimpleBooleanParser.orexpr_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR7 = default(IToken);
		SimpleBooleanParser.atom_return atom6 = default(SimpleBooleanParser.atom_return);
		SimpleBooleanParser.atom_return atom8 = default(SimpleBooleanParser.atom_return);

		object OR7_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "orexpr");
		DebugLocation(21, 25);
		try
		{
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:21:8: ( atom ( OR atom )* )
			DebugEnterAlt(1);
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:21:10: atom ( OR atom )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(21, 10);
			PushFollow(Follow._atom_in_orexpr167);
			atom6=atom();
			PopFollow();

			adaptor.AddChild(root_0, atom6.Tree);
			DebugLocation(21, 15);
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:21:15: ( OR atom )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==OR))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:21:16: OR atom
					{
					DebugLocation(21, 18);
					OR7=(IToken)Match(input,OR,Follow._OR_in_orexpr170); 
					OR7_tree = (object)adaptor.Create(OR7);
					root_0 = (object)adaptor.BecomeRoot(OR7_tree, root_0);

					DebugLocation(21, 20);
					PushFollow(Follow._atom_in_orexpr173);
					atom8=atom();
					PopFollow();

					adaptor.AddChild(root_0, atom8.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orexpr", 4);
			LeaveRule("orexpr", 4);
			LeaveRule_orexpr();
		}
		DebugLocation(21, 25);
		} finally { DebugExitRule(GrammarFileName, "orexpr"); }
		return retval;

	}
	// $ANTLR end "orexpr"

	private sealed partial class atom_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public atom_return(SimpleBooleanParser grammar) {OnCreated(grammar);}
		partial void OnCreated(SimpleBooleanParser grammar);
	}

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:22:1: atom : ( WORD | LPAREN expr RPAREN );
	[GrammarRule("atom")]
	private SimpleBooleanParser.atom_return atom()
	{
		EnterRule_atom();
		EnterRule("atom", 5);
		TraceIn("atom", 5);
		SimpleBooleanParser.atom_return retval = new SimpleBooleanParser.atom_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WORD9 = default(IToken);
		IToken LPAREN10 = default(IToken);
		IToken RPAREN12 = default(IToken);
		SimpleBooleanParser.expr_return expr11 = default(SimpleBooleanParser.expr_return);

		object WORD9_tree = default(object);
		object LPAREN10_tree = default(object);
		object RPAREN12_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(22, 34);
		try
		{
			// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:22:6: ( WORD | LPAREN expr RPAREN )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==WORD))
			{
				alt3 = 1;
			}
			else if ((LA3_0==LPAREN))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:22:8: WORD
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(22, 8);
				WORD9=(IToken)Match(input,WORD,Follow._WORD_in_atom182); 
				WORD9_tree = (object)adaptor.Create(WORD9);
				adaptor.AddChild(root_0, WORD9_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\projects\\common\\Antlr\\simpleboolean-parser\\SimpleBoolean.g:22:15: LPAREN expr RPAREN
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(22, 21);
				LPAREN10=(IToken)Match(input,LPAREN,Follow._LPAREN_in_atom186); 
				DebugLocation(22, 23);
				PushFollow(Follow._expr_in_atom189);
				expr11=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr11.Tree);
				DebugLocation(22, 34);
				RPAREN12=(IToken)Match(input,RPAREN,Follow._RPAREN_in_atom191); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 5);
			LeaveRule("atom", 5);
			LeaveRule_atom();
		}
		DebugLocation(22, 34);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _EOF_in_compileUnit40 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andexpr_in_expr145 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _orexpr_in_andexpr152 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_andexpr155 = new BitSet(new ulong[]{0x120UL});
		public static readonly BitSet _orexpr_in_andexpr158 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _atom_in_orexpr167 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _OR_in_orexpr170 = new BitSet(new ulong[]{0x120UL});
		public static readonly BitSet _atom_in_orexpr173 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _WORD_in_atom182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_atom186 = new BitSet(new ulong[]{0x120UL});
		public static readonly BitSet _expr_in_atom189 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _RPAREN_in_atom191 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}
